#!/usr/bin/env fish


set parent_tmp_dir (mktemp -d)
set cache_file $HOME/.cache/pacupdate
set repo_updates 0
set aur_updates 0
set git_updates 0

# setup fallbacks for envar settings
function set_or_fallback -S -a var fallback
    if not set -gq $var
        set -g $var $fallback
    end
end


set_or_fallback PACUPDATE_MIRRORLIST_STRING "?country=all&protocol=http&protocol=https&ip_version=4"
set_or_fallback PACUPDATE_MIRRORLIST_INTERVAL 1209600

# create a cache file if there isn't already one
if test ! -e $cache_file
    touch $cache_file
end


function test_sudo
    if not command -s sudo > /dev/null
        echo "Sudo not found on system. Aborting…"
        return 1
    end
end


function test_installed -a cmd
    if not command -s $cmd
        echo_important "$cmd not installed. Skipping…"
        return 1
    end
end


function mktemp
    # override mktemp to use $parent_tmp_dir as a sort of sandbox
    command mktemp -p "$parent_tmp_dir" $argv
end


function ring_bell
    # ring the terminal bell, call this before any interactive command
    printf \b
end


function s
    # shorthand for sudo that also rings the terminal bell when credentials aren't cached
    sudo -n true 2>/dev/null; or ring_bell
    sudo $argv;
end


function formatted_echo -a color prefix msg
    set_color -o $color
    echo -n "$prefix "
    set_color normal
    set_color -o
    echo $msg
    set_color normal
end


function echo_head -a msg no_lb
    # if $no_lb is non-zero, skip the linebreak
    test -z "$no_lb"; and echo ""
    formatted_echo green "==>" $msg
end


function echo_important -a msg
    formatted_echo blue "  ->" $msg
end


function confirm -a msg
    # show a confirm prompt that doesn't print user input
    set_color -i
    echo -n $msg
    set_color normal
    stty -echo
    head -n 1 - | read -l _ #throwaway var
    stty echo
    echo
end


function yn_prompt -a msg
    ring_bell
    set -l answer "0" # set answer to anything to keep the while loop running
    while test "$answer" != 'y' -a "$answer" != 'n' -a -n "$answer"
        read -n 1 -p "set_color -o; echo -n "(string escape $msg)" [Y/n]\ ; set_color normal" answer
        set answer (string lower $answer)
    end
    stty echo # workaround for a fixed bug that will disappear in future fish versions
    test "$answer" = 'y' -o -z "$answer"; and return 0; or return 1
end


function set_cache_var -a key value
    if string match -qr "^$key\s*=" < $cache_file
        string replace -r '^('$key'\s*=\s*).+$' '${1}'$value < $cache_file > $cache_file
    else
        echo "$key = $value" >> $cache_file
    end
end


function get_cache_var -a key
    string replace -rf '^'$key'\s*=\s*(.+)$' '$1' < $cache_file
end


function print_msg -a msg_id msg_file
    set -l record_mode 0
    set -l msg_chunk
    while read -l line
        switch $record_mode
            case 0
                string match -qi 'Message-Id: <'$msg_id'>' -- $line
                and set record_mode 1
            case 1
                string match -q 'X-List-Received-Date: *' -- $line
                and set record_mode 2
            case 2
                if string match -qr 'From (arch-)?announce@archlinux.org' -- $line
                    break
                else
                    set msg_chunk $msg_chunk $line
                end
        end
    end < $msg_file

    # leave leading and trailing empty lines for now
    string join \n $msg_chunk

end


function update_pacman_mirrorlist
    echo_head "Pacman mirrorlist outdated?" 1
    set -l last_update_mirrorlist (get_cache_var last_update_mirrorlist)
    if test -z $last_update_mirrorlist
        set_cache_var last_update_mirrorlist (date +%s)
        echo "There are no previous update checks for the mirrorlist."
    else if test (math (date +%s) - $last_update_mirrorlist) -ge $PACUPDATE_MIRRORLIST_INTERVAL
        set_cache_var last_update_mirrorlist (date +%s)
        echo_important "Yes."
    else
        echo "No."
        return
    end

    echo "Retrieving current copy…"
    set -l mirrorlist_temp (mktemp)
    curl -s "https://www.archlinux.org/mirrorlist/$PACUPDATE_MIRRORLIST_STRING" > $mirrorlist_temp 2>/dev/null
    or begin
        echo 'Error retrieving the mirrorlist. Is $PACUPDATE_MIRRORLIST_STRING correctly set up?'
        return 1
    end

    # cleaning up mirrorlist
    string replace -r '^#Server' 'Server' < $mirrorlist_temp > $mirrorlist_temp

    # backing up the old mirrorlist and setting the new one in place
    s cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup; or return 1
    s mv $mirrorlist_temp /etc/pacman.d/mirrorlist; or return 1
    echo_important "Mirrorlist updated."
end


function check_mailing_list
    echo_head "News in the Arch Mailing List?"
    set -l last_update_msg_id (get_cache_var last_update_msg_id)
    set -l mail_list_file (mktemp)
    echo "Retrieving current copy…"
    curl -s https://lists.archlinux.org/pipermail/arch-announce.mbox/arch-announce.mbox > $mail_list_file

    # get most recent message id from arch mailing list
    set -l msg_id_list (string match -r '(?<=^Message-ID: <)[^>]+' < $mail_list_file)

    if test -z $last_update_msg_id
        set_cache_var last_update_msg_id $msg_id_list[-1]
        echo "There are no previously recorded visits to the Arch Mailing List."
        yn_prompt "Continue anyway?"; and return 0; or return 1
    else if test $last_update_msg_id = $msg_id_list[-1]
        echo_important "No news."
        return
    else
        set -l last_update_msg_id_pos (contains -i $last_update_msg_id $msg_id_list)
        echo_important 'Yes, '(count $msg_id_list[$last_update_msg_id_pos..-1])' unread news items.'

        # collect all msg_ids for messages between now and $last_update_msg_id
        for msg_id in $msg_id_list[$last_update_msg_id_pos..-1]
            print_msg $msg_id $mail_list_file
            confirm 'Press Enter to continue.'
        end
        set_cache_var last_update_msg_id $msg_id_list[-1]
        yn_prompt "Continue with the updating process?"; and return 0; or return 1
    end
end


function check_repo_updates
    echo_head "Updates in Pacman's repos?"
    s pacman -Sy > /dev/null; or return 1
    set repo_updates (count (pacman -Qu))
    if test $repo_updates -gt 0
        echo_important 'Yes, '$repo_updates' new updates.'
    else
        echo_important "None."
    end
end


function check_aur_updates
    echo_head "Updates in the AUR?"
    set aur_updates (count (auracle sync -q))
    if test $aur_updates -gt 0
        echo_important 'Yes, '$aur_updates' new updates.'
    else
        echo_important "None."
    end
end


function install_repo_updates
    # skip if there are no aur_updates
    test $repo_updates -gt 0; or return 0

    set -l pacman_log (string replace -rf '^LogFile\s+=\s+(\S+)' '$1' < /etc/pacman.conf)
    set -l pacman_old_log (mktemp)
    set -l pacman_new_log (mktemp)
    if test -z $pacman_log
        set pacman_log "/var/log/pacman.log"
    end
    cp $pacman_log $pacman_old_log; or return 1

    echo_head "Installing updates from Pacman's repos…"
    s pacman -Su; or return 1
    comm -13 $pacman_old_log $pacman_log > $pacman_new_log
end


function install_aur_package -a pkg
    set -l orig_dir (pwd)
    set -l deps (auracle buildorder $pkg | string replace 'BUILD ' ''); or return 1

    # build dependencies and $pkg in correct order
    for dep_pkg in $deps
        echo_important "Building and installing $dep_pkg…"
        cd (mktemp -d --suffix "-$dep_pkg")
        git clone "https://aur.archlinux.org/$dep_pkg.git" .; or return 1
        makepkg -sri; or return 1
    end

    cd $orig_dir
end


function install_aur_updates
    # skip if there are no aur_updates
    test $aur_updates -gt 0; or return 0

    echo_head "Installing updates from the AUR…"

    # skip if auracle's not installed
    test_installed auracle; or return 0

    for aur_pkg in $aur_updates
        install_aur_package
        or yn_prompt "Error installing $aur_pkg. Continue anyway? "; or return 1
    end
end


function install_git_updates
    test $git_updates -gt 0; or return 0

    echo_head "Installing Git updates…"

    # skip if git's not installed
    test_installed git; or return 0
end


function install_updates
    # skip if there are no updates
    set -l total_updates (math $repo_updates + $aur_updates + $git_updates)
    if not test $total_updates -gt 0
        return
    end

    yn_prompt "Install total of $total_updates updates?"; or return 1
    install_repo_updates; or return 1
    install_aur_updates; or return 1
    install_git_updates; or return 1
end


test_sudo
and update_pacman_mirrorlist
and check_mailing_list
and check_repo_updates
and check_aur_updates
and install_updates

rm -rf $parent_tmp_dir
