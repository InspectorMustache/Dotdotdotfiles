#!/usr/bin/env fish

test -z $PASS_SUBNAME_SPLIT_CHAR; and set PASS_SUBNAME_SPLIT_CHAR '%'
test -z $PASSWORD_STORE_DIR; and set PASSWORD_STORE_DIR $HOME/.password-store
test -z $PASS_FALLBACK_USER; and set PASS_FALLBACK_USER "User"

# get name of currently active window
test -z "$argv"; and set argv ""
set active_line (string match -ri '^_NET_ACTIVE_WINDOW\(WINDOW\).+' (xprop -root))
set active_id (string replace -r '^[^#]+#\s(\S+)' '$1' "$active_line")
set name_line (string match -r 'WM_NAME\([^)]+\).+' (xprop -id $active_id))
set class_line (string match -r 'WM_CLASS\([^)]+\).+' (xprop -id $active_id))
set name (string match -r '"[^"]+"$' "$name_line")
set class (string match -r '"[^"]+"$' "$class_line")
set name (string replace -a ' ' '_' "$name")
set class (string replace -a ' ' '_' "$class")


function get_value -a pass key fallback
    pass show $pass >/dev/null 2>&1; or return 1
    # get the value for $key
    pass field "$key" "$pass" 2>/dev/null | read value; or set value "$fallback"
    if test -n "$value"
        echo $value
    else
        return 1
    end
end


function xdo_type
    test -z "$argv"; and return 1
    xdotool type --clearmodifiers "$argv"
end


function xdo_pass_entry -a pass
    set user (get_value $pass "user" "$PASS_FALLBACK_USER"); or return 1
    set pass_string (pass show $pass | head -n 1); or return 1
    set field_div (get_value $pass "xdoDiv")
    test -z "$field_div"; and set field_div "Tab"
    xdo_type $user
    xdotool keyup Super
    xdotool key --clearmodifiers (string split " " $field_div)
    xdotool keyup Super
    xdo_type $pass_string
    xdotool keyup Super
    xdotool key --clearmodifiers Return
end


function loop_candidates -S -a prop
    # loop through candidates and find one that matches $prop
    for password in $passes
        set barepass (command basename $password)
        if string match -qie "$barepass" $prop
            set candidates $candidates $password
            continue
        end

        set subs (string split "$PASS_SUBNAME_SPLIT_CHAR" "$barepass")
        if [ ! "$subs" = "$barepass" ]
            for sub in $subs
                if not contains $password $candidates;
                   and string match -qie "$sub" $prop
                    set candidates $candidates $password
                    continue
                end
            end
        end
    end
end


# get list of all pass files
set passes (string replace -r '^.+?\.password-store/(.+?)\.gpg$' '$1' $PASSWORD_STORE_DIR/**/*)

# loop through files and find one that matches based on name property or if
# that doesn't work class property
set candidates
loop_candidates $name
if test -z "$candidates"
    loop_candidates $class
end

# send candidate to pass; use dmenu to select one if there are too many
set cand_num (count $candidates)
set final_candidate

if test $cand_num -eq 1
    # if there was only one password found set that to final candidate
    set final_candidate $candidates
    notify-send "Found $final_candidate."
else if test $cand_num -gt 1
    # if there's more than one, select one with dmenu
    notify-send 'Too many candidates.'
    for candidate in $candidates
        printf '%s\n' $candidate
    end | dmenu | read final_candidate
else 
    # if there's none, also select one with dmenu
    notify-send 'Nothing found. Please select manually.'
    for candidate in $passes
        printf '%s\n' $candidate
    end | dmenu | read final_candidate
end

if test -n "$final_candidate"
    # handle different command flags
    switch $argv
        case "-l"
            xdo_type (get_value $final_candidate "user" "$PASS_FALLBACK_USER"); or exit 1
        case "-f"
            set field (pass field -l $final_candidate | dmenu); or exit 1
            xdo_type (get_value $final_candidate "$field"); or exit 1
        case "-x"
            xdo_pass_entry $final_candidate; or exit 1
        case "*"
            pass show -c $final_candidate; or exit 1
    end
    and notify-send -u low "Retrieved data from $final_candidate."
else
    notify-send 'No password selected.'
end
